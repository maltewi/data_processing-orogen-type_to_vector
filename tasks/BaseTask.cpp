/* Generated from orogen/lib/orogen/templates/tasks/Task.cpp */

#include <rtt/base/PortInterface.hpp>
#include <rtt/base/InputPortInterface.hpp>
#include <rtt/DataFlowInterface.hpp>
#include <rtt/typelib/TypelibMarshallerBase.hpp>
#include <typelib/registry.hh>

#include <general_processing/VectorTocMaker.hpp>
#include <general_processing/Converter.hpp>

#include <base/eigen.h>

#include "VectorDataStorage.hpp"

#include "BaseTask.hpp"

using namespace general_processing;
using RTT::log;
using RTT::endlog;
using RTT::Debug;
using RTT::Info;
using RTT::Error;

namespace general_processing {
class TimeNowConversion : public AbstractConverter {

public:
    TimeNowConversion(const VectorToc& toc) : AbstractConverter(toc) {}

    VectorOfDoubles apply (void* data, bool create_places=false) {
        mVector.clear();
        mVector.push_back(base::Time::now().toSeconds());
        if (mPlaceVector.empty())
            mPlaceVector.push_back("time"); 
        return mVector;
    }
};
}

BaseTask::BaseTask(std::string const& name)
    : BaseTaskBase(name), mpRegistry(new Typelib::Registry())
{
}

BaseTask::BaseTask(std::string const& name, RTT::ExecutionEngine* engine)
    : BaseTaskBase(name, engine), mpRegistry(new Typelib::Registry())
{
}

BaseTask::~BaseTask()
{
    delete mpRegistry;
}

RTT::base::OutputPortInterface* BaseTask::createOutputPort(const std::string& port_name,
        const std::string& type_name) {
    
    RTT::base::PortInterface *pi = ports()->getPort(port_name);
    if(pi)
    {
        // Port exists. Should not be there already.
        log(Info) << "Port " << port_name << " is already registered." << endlog();
        return 0;
    }

    /* Check if port type is known */
    RTT::types::TypeInfoRepository::shared_ptr ti = 
        RTT::types::TypeInfoRepository::Instance();
    RTT::types::TypeInfo* type = ti->type(type_name);
    if (!type)
    {
    	log(Error) << "Cannot find port type " << type_name << 
            " in the type info repository." << endlog();
	
        return 0;
    }
    
    /* Add output port */
    RTT::base::OutputPortInterface *out_port = type->outputPort(port_name);
    if (!out_port)
    {
        log(Error) << "An error occurred during output port generation." << endlog();
        return 0;
    }
    
    ports()->addPort(out_port->getName(), *out_port);

    log(Info) << "Added output port " << port_name << " to task." << endlog();
     
    return out_port;
}

bool BaseTask::addDebugOutput(DataVector& vector, int vector_idx) {

    if (_debug_ports.get()) {
        std::string idx_str = boost::lexical_cast<std::string>(vector_idx);
        vector.dataVectorOut = createOutputPort("debug_data_"+idx_str, "/base/VectorXd");
        vector.timeVectorOut = createOutputPort("debug_time_"+idx_str, "/base/VectorXd");
        if ( ! vector.dataVectorOut || ! vector.timeVectorOut )
            return false;
    }

    if (_debug_places.get()) {
        std::string idx_str = boost::lexical_cast<std::string>(vector_idx);
        vector.placesVectorOut = createOutputPort("debug_places_"+idx_str, 
                "/std/string");
        if ( ! vector.placesVectorOut ) return false;
    }

    return true;
}

bool BaseTask::addInputPort(DataInfo& di, RTT::base::InputPortInterface* reader) {
    
    RTT::types::TypeInfo const* type = reader->getTypeInfo();

    orogen_transports::TypelibMarshallerBase* transport = 
        dynamic_cast<orogen_transports::TypelibMarshallerBase*>(
                type->getProtocol(orogen_transports::TYPELIB_MARSHALLER_ID) );

    if (! transport) {
        log(Error) << "cannot report ports of type " << type->getTypeName() << 
            " as no typekit generated by orogen defines it" << endlog();
        return false;
    }

    mpRegistry->merge(transport->getRegistry());

    if (! mpRegistry->has(transport->getMarshallingType())) {
        log(Error) << "cannot report ports of type " << type->getTypeName() << 
            " as I can't find a typekit Typelib registry that defines it" << endlog();
        return false;
    }

    ports()->addEventPort(reader->getName(), *reader); 
   
    di.typelibMarshaller = transport;
    di.readPort = reader;
    di.handle = di.typelibMarshaller->createSample();
    di.sample = di.typelibMarshaller->getDataSource(di.handle);

    return true;
}

bool BaseTask::addDataInfo(RTT::base::InputPortInterface* reader, int vector_idx,
        const std::string& slice) {
    
    if ( vector_idx < 0 ) return false;

    DataInfo di;
    
    if ( !addInputPort(di, reader) ) return false;
    
    di.conversions = VectorConversion(reader->getName());

    if ( mVectors.size() <= vector_idx ) mVectors.resize(vector_idx+1);

    di.mpVector = &(mVectors.at(vector_idx));

    if ( !di.mpVector->dataVectorOut &&
         !di.mpVector->timeVectorOut && 
         !di.mpVector->placesVectorOut ) { 
        
        if ( !addDebugOutput(*di.mpVector, vector_idx) ) return false;
    }

    di.mpTargetVector = di.mpVector->addVectorPart(di);
    di.newSample.mpInfo = &di;
    
    aggregator::StreamAligner::Stream<general_processing::SampleData>::callback_t cb = 
        boost::bind(&BaseTask::sampleCallback,this,_1,_2);

    di.streamIndex = _stream_aligner.registerStream<general_processing::SampleData>(cb, 
            0, base::Time());

    di.pStreamAligner = &_stream_aligner;
    
    VectorToc toc = VectorTocMaker().apply(
        *(mpRegistry->get(di.typelibMarshaller->getMarshallingType())) );

    VectorToc toc_sliced = VectorTocSlicer::slice(toc, slice);
    VectorToc toc_time = VectorTocSlicer::slice(toc, _time_fields.get());

    typedef AbstractConverter::Pointer ConvertPtr;

    ConvertPtr c_sliced_ptr;
    if ( toc_sliced.isFlat() )
        c_sliced_ptr = ConvertPtr(new FlatConverter(toc_sliced));
    else
        c_sliced_ptr = ConvertPtr(new ConvertToVector(toc_sliced, *mpRegistry));
    
    ConvertPtr c_time_ptr;
    if ( toc_time.empty() )
        c_time_ptr = ConvertPtr(new TimeNowConversion(toc_time));
    else {
        toc_time.resize(1);
        ConvertPtr c_single_ptr(new SingleConverter(toc_time));
        c_time_ptr = ConvertPtr(new MultiplyConverter(c_single_ptr, 1.0e-6));
    }
    
    di.conversions.addConverter(c_sliced_ptr);
    di.conversions.addConverter(c_time_ptr);
    
    mDataInfos.push_back(di);
    
    return true;
}

void BaseTask::sampleCallback(base::Time const& timestamp, SampleData const& sample) {

    *(sample.mpInfo->mpTargetVector) = sample;

    sample.mpInfo->mpVector->mUpdated = true;
    sample.mpInfo->mpVector->mUpdatedTime = true;

    if ( ! sample.mPlaces.empty() )
        sample.mpInfo->mpVector->mUpdatedPlaces = true;
    else
        sample.mpInfo->mpVector->mUpdatedPlaces = false;
}

bool BaseTask::addComponentToVector(::std::string const & component, 
        ::std::string const & slice, boost::int32_t to_vector)
{
    return false;
}

bool BaseTask::addPortToVector(::std::string const & component, ::std::string const & port, 
        ::std::string const & slice, boost::int32_t to_vector)
{
    return false;
}

bool BaseTask::createInputPort(::std::string const & port_name, 
                               ::std::string const & type_name, 
                               ::std::string const & slice, 
                               boost::int32_t to_vector)
{
    
    /* Check if port already exists (check name) */
    RTT::base::PortInterface *pi = ports()->getPort(port_name);
    if(pi)
    {
        // Port exists. Returns success.
        log(Info) << "Port " << port_name << " is already registered." << endlog();
        return true;
    }

    /* Check if port type is known */
    RTT::types::TypeInfoRepository::shared_ptr ti = 
        RTT::types::TypeInfoRepository::Instance();
    RTT::types::TypeInfo* type = ti->type(type_name);
    if (!type)
    {
    	log(Error) << "Cannot find port type " << type_name << 
            " in the type info repository." << endlog();
	
        return false;
    }
    
    /* Create input port */
    RTT::base::InputPortInterface *in_port = type->inputPort(port_name);
    if (!in_port)
    {
        log(Error) << "An error occurred during input port generation." << endlog();
        return false;
    }
    
    //ports()->addPort(in_port->getName(), *in_port);

    return addDataInfo(in_port, to_vector, slice);  
}

void BaseTask::processingStepCallback() {

}

void BaseTask::getDataVector(int vector_idx, base::VectorXd& vector) {
    mVectors.at(vector_idx).getDataVector(vector);
}

void BaseTask::getTimeVector(int vector_idx, base::VectorXd& time_vector) {
    mVectors.at(vector_idx).getTimeVector(time_vector);
}

void BaseTask::getExpandedTimeVector(int vector_idx, base::VectorXd& time_vector) {
    mVectors.at(vector_idx).getExpandedTimeVector(time_vector);
}

// bool BaseTask::configureHook()
// {
//     if (! BaseTaskBase::configureHook())
//         return false;
//     return true;
// }
// bool BaseTask::startHook()
// {
//     if (! BaseTaskBase::startHook())
//         return false;
//     return true;
// }

void BaseTask::updateHook()
{
    BaseTaskBase::updateHook();

    DataInfos::iterator data_it = mDataInfos.begin();

    for ( ; data_it != mDataInfos.begin(); data_it++ )
        while ( data_it->update(_debug_places.get() ) ); 

    while ( _stream_aligner.step() ) {
        processingStepCallback();
    }
}

// void BaseTask::errorHook()
// {
//     BaseTaskBase::errorHook();
// }

void BaseTask::stopHook()
{
    BaseTaskBase::stopHook();
    _stream_aligner.clear();
}

void BaseTask::cleanupHook()
{
    BaseTaskBase::cleanupHook();

    DataInfos::iterator it = mDataInfos.begin();
    for ( ; it != mDataInfos.end(); it++) {
        it->typelibMarshaller->deleteHandle(it->handle);
        _stream_aligner.unregisterStream(it->streamIndex);
        ports()->removePort(it->readPort->getName());
    }

    mDataInfos.clear();
    mVectors.clear();
     
}

